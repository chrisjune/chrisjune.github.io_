---
layout: post-sidebar
date: 2020-01-21
title: "Linux Command 2 - top을 통해 살펴보는 프로세스 정보들"
categories: linux
author_name : Tomas
author_url : /author/tom
author_avatar: tom
show_avatar : false
read_time : 10
feature_image: feature-wolf
show_related_posts: true
square_related: recommend-fire
---
**top을 통해 살펴보는 프로세스 정보들**

## 2.1 시스템의 상태 살피기
* `top -b`
    * -b 옵션으로 기존 정보 그대로 유지
    ```shell script
    top - 12:28:05 up 1 min,  0 users,  load average: 0.68, 0.31, 0.11
    Tasks:   2 total,   1 running,   1 sleeping,   0 stopped,   0 zombie
    %Cpu(s): 12.2 us,  7.8 sy,  0.0 ni, 76.7 id,  2.3 wa,  0.0 hi,  0.9 si,  0.0 st
    KiB Mem :  2047132 total,   403320 free,   756340 used,   887472 buff/cache
    KiB Swap:  1048572 total,  1048572 free,        0 used.  1141920 avail Mem

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
      1 root      20   0   18504   3296   2876 S   0.0  0.2   0:00.03 bash
     15 root      20   0   36480   3036   2684 R   0.0  0.1   0:00.00 top
    ```
    1. Up: 서버가 구동된 시각과 구동시간
    2. Users: 로그인해있는 user의 수
    3. Load average: 서버에서 실행중 또는 대기중인 프로세스의 수의 합
    4. Tasks: 구동중인 프로세스의 개수
    5. CPU, Memory, Swap memory의 사용량을 나타냄
    6. PR: 프로세스의 실행 우선순위. 낮은 수일 수록 높은 우선순위를 나타낸다.
    7. NI: PR값을 얼만큼 조절할 것인지 결정. PR값에 더하여 우선순위를 조정한다
    8. VIRT, RES, SHR: 프로세스가 사용하는 메모리양을 나타내는 정보. 메모리 누수를 확인할 수 있는 부분!
    9. S: 프로세스의 상태를 나타내는 정보
## 2.2 VIRT, RES, SHR
* `VIRT`:
    * task(프로세스)가 사용하고 있는 virtual memory의 전체용량
    * 프로세스에 할당된 가상 메모리 전체의 크기
    * 실제로 할당되지 않은 가상의 공간이기 때문에 크기에 따른 제약이나 문제가 발생하지 않는다
* `RES`
    * task(프로세스)가 사용하고 있는 physical memory의 용량
    * 실제로 메모리에 올려서 사용하고 있는 크기
    * 메모리 점유율이 높은 프로세스는 RES를 확인해야 한다
* `SHR`
    * 다른 프로세스와 공유하고 있는 shared memory의 용량
    * 예시, 리눅스 glibc 라이브러리
## 2.3 VIRT와 RES그리고 Memory Commit의 개념
* `Memory Commit`
    * 프로세스는 독립된 작업공간이 필요하기 때문에 Virtual memory 공간을 할당받고, 실제로 메모리에 쓰게될 때 할당하게 된다
    * 커널로부터 메모리를 할당 받고 메모리 주소를 전달받지만, 실제 물리메모리에 할당하지 않는 동작방식
    * virt: 가상메모리는 프로세스가 커널로부터 사용을 예약받은 메모리
    * malloc()과 같은 시스템 콜로 자신이 필요로 하는 메모리할당을 요청
    * 가용용량을 확인 후 가상메모리 주소를 전달. 하지만 실제 물리 메모리에 할당하지 않음
* `Page Table`
    * 물리 메모리와 가상메모리가 매핑된 커널 전역 변수
    * 프로세스에 할당된 가상메모리에 실제 쓰기 작업을 하면 page fault가 발생
    * 이때 물리 메모리에 가상 메모리를 매핑함
* `Memory Commit을 사용하는 이유`
    * COW(Copy on Write)를 사용하기 위하여
    * COW
        * 메모리 리소스를 효율적으로 쓰기 위하여 프로세스가 복사될 때, 복사된 프로세스는 기존의 메모리 리소스를 바라보고 있다가
        * 프로세스가 리소스에 쓰는작업이 될때, 복사를 하는 동작 방식
    ```python
    x = []
    y = x # x and y use the same buffer 
    y += [1] # now y use a different buffer, x usee the same old buffer.
    ```
    
  
     
